\documentclass[a4paper,12pt,russian, oneside]{article}

\usepackage{comment} % Многострочные комментарии

% XeTeX packages
\usepackage[cm-default]{fontspec} % or install lmodern and remove cm-default opt
\usepackage{xunicode} % some extra unicode support
\usepackage{xltxtra} % \XeLaTeX macro


\tolerance=1000
\emergencystretch=0.74cm

\usepackage{indentfirst} %делать отступ в начале параграфа
\setlength{\parindent}{1.25cm}
\setlength{\parskip}{3.0mm} %Расстояние между абзацами 



\usepackage[pdfborder = {0 0 0}]{hyperref} %гиперссылки в документе.

\usepackage[utf8]{inputenc}	% кодировка текста
\usepackage[russian]{babel} % руссификация по Бабелю
\usepackage{graphics}

%\usepackage[clean,pdf]{svg}

\usepackage{amsmath, amsfonts} % для расширенных настроек ссылок на формулы
\usepackage{extsizes} % использование шрифтов большего кегля 

\usepackage{fancyvrb} % Добавляет продвинутые Verbatim и Verb

\usepackage{epsfig} % удобно вставлять рисунки в строку текста
\usepackage[usenames,dvipsnames]{pstricks}
\usepackage{pst-grad} % For gradients
\usepackage{pst-plot} % For axes

\usepackage{graphicx,xcolor}
\usepackage{minted}



\usepackage{array}
\usepackage{tabularx}
\usepackage{supertabular}
\usepackage{longtable} % для создания таблиц, переносящихся на другую страницу

\usepackage{textcomp} % Ввод различных знаков
\usepackage{keystroke} % для отображения символов клавиш
\usepackage{bytefield} %для создания таблиц с битовыми полями
\usepackage{filecontents} %для включения в документ содержимого файлов

\usepackage{tikz} % Пакет для рмсования диаграмм
\usepackage{tikz-timing}[2009/12/09]
\usetikzlibrary{arrows}
\usepackage{tikzit}
\input{sample.tikzstyles}

\usetikzlibrary{positioning,arrows,automata,plotmarks} %В данном случае нам потребуются positioning и arrows, которые нужны для расположения элементов друг относительно друга и рисования стрелок между ними соответственно.
\usetikzlibrary{shapes,snakes}
\usepackage{schemabloc}

\usepackage{makecell} % Для многострочных ячеек таблицы
\usepackage{colortbl} % Для раскрашивания ячеек в таблицах


\setromanfont{Times New Roman}
\setsansfont{Arial}
\setmonofont{Consolas} %\texttt{} \verb||
\setmainfont{Times New Roman}



%\newcommand{\chaptermarkI}[1]{\markright{#1}}
%\renewcommand{\chaptermark}[1]{\markright{ГЛАВА\ \thepart.\ #1}}


\usepackage{eso-pic}


\usepackage{newverbs}
\renewenvironment{verbatim}
{\semiverbatim\color{Violet}}
{\endsemiverbatim}
\renewcommand{\verb}{\collectverb{\color{Violet}}}

\let\OldTexttt\texttt
\renewcommand{\texttt}[1]{\textcolor{Violet}{\OldTexttt{#1}}}


\usepackage[top=2.0cm, left=3.0cm, right=1.5cm, bottom=2.0cm]{geometry}


\input{commands.tex}

\begin{document}% Начало самого документа (содержательной части)

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{4} % n=4 это chapter, section, subsection, subsubsection и paragraph; -> toc


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%% Используемые тэги в проекте %%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}


% Цитирование Си-кода
\begin{CcodeII}
--//--
\end{CcodeII}

% Цитирование bash-кода
\begin{BASHcode}
--//--
\end{BASHcode}

%Цитируемый текст
\begin{TEXTcode}
--//--
\end{TEXTcode}

% Цитирование make-кода
\begin{MAKEFILEcode}
--//--
\end{MAKEFILEcode}

% Для текстового псевдорисунка
\begin{TEXTpicture}
--//--
\end{TEXTpicture}



%Цитирование внутри текста
\verb|--//--|

\texttt{}
%Жирный жрифт
\textbf{}
%Наклонный шрифт
\textit{}

%Ссылка
\url{https://--//--}

%Ненумерованное перечисление
\begin{itemize}
  \item 
  \item 
\end{itemize}

%Нумерованное перечисление
\begin{enumerate}
  \item 
  \item 
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Секция}

  \subsection*{Подсекция}

    \paragraph*{Параграф}
    \

%Картинка из многостраничного *.pdf
\begin{figure}[H]%
  \centering
  \includegraphics[scale = 1.0, page = 7, viewport=20.0mm 25.0mm 180.0mm 125.0mm, clip]{origin/LinuxDeviceDriversDevelopment_ColorImages.pdf}%
  \caption{Шинная архитектура драйверов с сновной псевдошиной} 
\end{figure}% scale = 0.3, width=\textwidth

%Таблица в две колони с автопереносом на другую страницу
\small
\begin{longtable}{|C{50mm}|C{100mm}|}
  \caption{Прерывания} \label{t:interrupts} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{50mm}|}{\centering Номер прерывания} &
  \multicolumn{1}{L{100mm}|}{\centering Описание} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:interrupts}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{50mm}|}{\centering Номер прерывания} &
  \multicolumn{1}{L{100mm}|}{\centering Описание} \\\hline
  \endhead
   0      &  Ошибка деления на ноль    \\ \hline
\end{longtable} \normalsize



\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagestyle{empty} % нумерация выкл.
\

\vspace{70mm}
\parbox{1\textwidth}{\centering
\LARGE Библиотека 'lproc\_queue'

\Large Расширение языка lua 5.3+
}

\vspace{155mm}
\parbox{1\textwidth}{\centering
\today
}




\newpage
\pagestyle{plain} % нумерация вкл.
\tableofcontents % Содержание

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Назначение}


Проект представляет собой библиотеку многопоточности,
основанной на библиотеке Linux pthread для Lua 5.3+ (\url{https://www.lua.org/pil}).

Исходники основаны на проекте из книжки \url{https://www.lua.org/pil/3/lproc.c}.
Недостатком оригинального проекта является то, что межпоточная коммуникация
основана на одиночных сообщениях, которые вызывают блокировку, скажем,
отправляющего сообщение потока в случае если получатель ещё не прочитал
предыдущее сообщение. В результате потоки ждут друг друга и нередко
всё самоблокируется.

В данной библиотеке механизм сообщений между потоками полностью заменён.
Новый механизм основан на очередях сообщений. Каждая очередь состоит из 256
элементов. Каждый элемент содержит 256 байт. Эти размеры можно переопределить
на стадии компиляции. Всего таких очередей может быть сколько угодно. Очереди
организованы в кольцевой двусвязанный список.

Благодаря механизму очередей сообщений становится возможным реализация 
неблокирующих вызовов 'положить в очередь' и 'извлечь из очереди'. Таким
образом, потоки выполняются независимо друг от друга и в тоже время обмениваются
друг с другом данными.

Исключительные ситуации 'очередь пуста' и 'очередь заполнена' обрабатываются и
возвращаются в Lua.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Сборка}

Для сборки нужны пакеты \verb|lua5.3|, \verb|liblua5.3-dev|, \verb|make|, \verb|gcc|.


\subsection{Сборка под Eclipse CDT}

\begin{enumerate}
\item Открыть Eclipse CDT.

\item \textbf{File} $\rightarrow$ \textbf{Import} $\rightarrow$ \textbf{Existing Progect into Workspace}, нажмите \keystroke{Next>}

\item В \textbf{Select root directory} укажите путь к файлу \verb|.progect| проекта, нажмите \keystroke{Finish}

\item Нажмите \keystroke{Build}. Результат появится папке \verb|./Release*|
\end{enumerate}



\subsection{Сборка под make}


\begin{BASHcode}
cd ~/lproc_queue/lproc_queue
make
\end{BASHcode}

При необходимости, нужно отредактировать пути к компилятору и lua в файле \verb|makefile|.



\subsection{Результат компиляции}

В процессе компиляции создаётся \verb|lproc_queue.so| lua - библиотека.

\subsection{Первый запуск}

Тестовый проект лежит в папке \verb|lproc_queue/lproc_queue/tests/probe_01/|
рядом с символической ссылкой на библиотеку. Для запуска теста надо перейти
в эту папку и ввести команду.
\begin{BASHcode}
lua5.3 ./probe_01.lua
\end{BASHcode}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Поддерживаемые платформы}

\subsection{Ubuntu 20.04}

Проект собирается, но тестировался не в полном объёме...


%\subsection{Встраиваемые Linux - системы на базе ARM/Cortex}

%Проект собирается, но тестировался не в полном объёме...




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Описание функций}

\subsection{\texttt{version()} - версия библиотеки}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ version() }} \label{t:version} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering  (string version) = version() } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:version}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & string & version &  Строка с версиями библиотек &  \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local version = lproc_queue.version()     --[[ <--- ]]
print(version)
\end{Lua}



\newpage
\subsection{\texttt{delay\_ms()} - задержка в миллисекундах}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ delay\_ms(integer ms) }} \label{t:delay_ms} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering  delay\_ms() } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:delay_ms}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorArgs}
  \multicolumn{5}{|c|}{\centering Аргументы } \\\hline
  1 & integer & ms & На сколько миллисекунд задержать &  \\ \hline
\end{longtable} \normalsize

\begin{Lua}
local lproc_queue = require('lproc_queue')
...
lproc_queue.delay_ms(300)  --[[ <--- ]]
\end{Lua}



\newpage
\subsection{Процессы}


\subsubsection{\texttt{proc\_start()} - создание и запуск процесса}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ proc\_start() }} \label{t:proc_start} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering (boolean ret) = proc\_start(string proc\_body) } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:proc_start}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorArgs}
  \multicolumn{5}{|c|}{\centering Аргументы } \\\hline
  1 & string & proc\_body & Строка текста, содержащая Lua - код дочернего процесса &  \\ \hline
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & boolean & ret & \parbox{73mm}{\vspace{1mm} 
                                    \texttt{false} - в случае ошибки;\\
                                    \texttt{true} - в случае успеха.
                                   } & \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local proc = [[
-- Библиотека 'lproc_queue' автоматически подключается к созданному процессу
while true do
  lproc_queue.delay_ms(500)
  print('from proc')
end
]]

local ret = lproc_queue.proc_start(proc)  --[[ <--- ]]

if( ret == false) then
  print('ERROR')
  os.exit()
end

while true do
  lproc_queue.delay_ms(500)
end

\end{Lua}


\newpage
\subsubsection{\texttt{proc\_exit()} - самозавершение дочернего процесса}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ proc\_exit() }} \label{t:proc_exit} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering proc\_exit() } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:proc_exit}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorArgs}
  \multicolumn{5}{|c|}{\centering Аргументы } \\\hline
   &  &  & Функция вызывается из дочернего процесса, не принимает аргументов &  \\ \hline
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
   &  &  & Не возвращает аргументов & \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local proc = [[
-- Библиотека 'lproc_queue' автоматически подключается к созданному процессу

  lproc_queue.delay_ms(500)
  print('from proc')

  lproc_queue.proc_exit()  --[=[ <--- ]=]
]]

local ret = lproc_queue.proc_start(proc)

if( ret == false) then
  print('ERROR')
end

while true do
  lproc_queue.delay_ms(500)
end

\end{Lua}






\newpage
\subsection{Очереди сообщений}

\subsubsection{\texttt{queue\_create()} - создание очереди сообщений}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ queue\_create() }} \label{t:queue_create} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering (integer queue\_pointer) = queue\_create() } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:queue_create}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & integer & queue\_pointer & \parbox{73mm}{\vspace{1mm} 
                                                 \texttt{0} - в случае ошибки;\\
                                                 \texttt{указатель на объект очереди} - в случае успеха.
                                                } & \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local queue__to_proc = lproc_queue.queue_create()  --[[ <--- ]]

if (queue__to_proc == 0) then
  print('ERROR')
end

\end{Lua}


\newpage
\subsubsection{\texttt{queue\_destroy()} - уничтожение очереди сообщений}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ queue\_destroy() }} \label{t:queue_destroy} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering (boolean ret) = queue\_destroy(integer queue\_pointer) } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:queue_destroy}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorArgs}
  \multicolumn{5}{|c|}{\centering Аргументы } \\\hline
  1 & integer & queue\_pointer & Указатель на объект очереди &  \\ \hline
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & boolean & ret & \parbox{73mm}{\vspace{1mm} 
                                    \texttt{false} - в случае ошибки;\\
                                    \texttt{true} - в случае успеха.
                                   } & \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local queue__to_proc = lproc_queue.queue_create()

if (queue__to_proc == 0) then
  print('ERROR')
  os.exit()
end

local ret = lproc_queue.queue_destroy(queue__to_proc)  --[[ <--- ]]

if (ret == false) then
  print('ERROR')
  os.exit()
end

\end{Lua}






\newpage
\subsubsection{\texttt{queue\_push()} - неблокирующее помещение сообщения в очередь}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ queue\_push() }} \label{t:queue_push} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering (boolean ret), (integer queue\_space) = queue\_push(integer queue\_pointer, lstring byte\_array) } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:queue_push}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorArgs}
  \multicolumn{5}{|c|}{\centering Аргументы } \\\hline
  1 & integer & queue\_pointer & Указатель на объект очереди &  \\ \hline
  2 & lstring & byte\_array    & Массив байт или сторка &  \\ \hline
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & boolean & ret & \parbox{73mm}{\vspace{1mm} 
                                    \texttt{false} - в случае ошибки;\\
                                    \texttt{true} - в случае успеха.
                                   } & \\ \hline
  2 & integer & queue\_space & Если первый возвращаемый аргумент \texttt{true}, то количество оставшегося свободного места для сообщений в очереди. & \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local proc_pattern = [[
local channel_in = <channel_in>
local ret, message, queue_count, queue_space

-- Библиотека 'lproc_queue' автоматически подключается к созданному процессу
while true do
  lproc_queue.delay_ms(500)
  print('from proc')
  ret, message, queue_count = lproc_queue.queue_nb_pop(channel_in)
end
]]


local queue__to_proc = lproc_queue.queue_create()
local proc = string.gsub(proc_pattern, '<channel_in>', string.format("0x%016X", queue__to_proc))

local ret = lproc_queue.proc_start(proc)

if (ret == false) then
  print('ERROR')
  os.exit()
end

while true do
  lproc_queue.delay_ms(321)
  ret, queue_space = lproc_queue.queue_push(queue__to_proc, 'message')  --[[ <--- ]]
  if (ret == false) then
    print('ERROR')
  end
end

\end{Lua}




\newpage
\subsubsection{\texttt{queue\_nb\_pop()} - неблокирующее извлечение сообщения из очереди}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ queue\_nb\_pop() }} \label{t:queue\_nb\_pop} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering (boolean ret), (lstring byte\_array), (integer queue\_count) = queue\_nb\_pop(integer queue\_pointer) } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:queue_nb_pop}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorArgs}
  \multicolumn{5}{|c|}{\centering Аргументы } \\\hline
  1 & integer & queue\_pointer & Указатель на объект очереди &  \\ \hline
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & boolean & ret & \parbox{73mm}{\vspace{1mm} 
                                    \texttt{false} - в случае ошибки;\\
                                    \texttt{true} - в случае успеха.
                                   } & \\ \hline
  2 & lstring & byte\_array  & Если первый возвращаемый аргумент \texttt{true}, то содержимое сообщения в виде массива байт &  \\ \hline
  3 & integer & queue\_count & Если первый возвращаемый аргумент \texttt{true}, то количество накопившихся сообщений в очереди. & \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local proc_pattern = [[
local channel_in = <channel_in>
local ret, message, queue_count, queue_space

-- Библиотека 'lproc_queue' автоматически подключается к созданному процессу
while true do
  lproc_queue.delay_ms(500)
  print('from proc')
  ret, message, queue_count = lproc_queue.queue_nb_pop(channel_in) --[=[ <--- ]=]
  if( ret == false) then
    print('from proc: ERROR')
  else
    print('from proc: meaasge = \''..tostring(message)..'\'')
  end
end
]]


local queue__to_proc = lproc_queue.queue_create()
local proc = string.gsub(proc_pattern, '<channel_in>', string.format("0x%016X", queue__to_proc))

local ret = lproc_queue.proc_start(proc)

if (ret == false) then
  print('ERROR')
  os.exit()
end

while true do
  lproc_queue.delay_ms(321)
  ret, queue_space = lproc_queue.queue_push(queue__to_proc, 'message')
  if (ret == false) then
    print('ERROR')
  end
end

\end{Lua}















\newpage
\subsection{Семафоры}

\subsubsection{\texttt{sem\_create()} - создание семафора}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ sem\_create() }} \label{t:sem_create} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering (integer sem\_pointer) = sem\_create() } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:sem_create}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & integer & sem\_pointer & \parbox{73mm}{\vspace{1mm} 
                                                 \texttt{0} - в случае ошибки;\\
                                                 \texttt{указатель на объект семафора} - в случае успеха.
                                                } & \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local sem__to_proc = lproc_queue.sem_create()  --[[ <--- ]]

if (sem__to_proc == 0) then
  print('ERROR')
end

\end{Lua}




\newpage
\subsubsection{\texttt{sem\_destroy()} - уничтожение семафора}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ sem\_destroy() }} \label{t:sem_destroy} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering (boolean ret) = sem\_destroy(integer sem\_pointer) } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:sem_destroy}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorArgs}
  \multicolumn{5}{|c|}{\centering Аргументы } \\\hline
  1 & integer & sem\_pointer & Указатель на объект семафора &  \\ \hline
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & boolean & ret & \parbox{73mm}{\vspace{1mm} 
                                    \texttt{false} - в случае ошибки;\\
                                    \texttt{true} - в случае успеха.
                                   } & \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local sem__to_proc = lproc_queue.sem_create()

if (sem__to_proc == 0) then
  print('ERROR')
  os.exit()
end

local ret = lproc_queue.sem_destroy(sem__to_proc)  --[[ <--- ]]

if (ret == false) then
  print('ERROR')
  os.exit()
end

\end{Lua}


\newpage
\subsubsection{\texttt{sem\_post()} - неблокирующая установка семафора}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ sem\_post() }} \label{t:sem\_post} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering (boolean ret) = sem\_post(integer sem\_pointer) } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:sem_post}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorArgs}
  \multicolumn{5}{|c|}{\centering Аргументы } \\\hline
  1 & integer & sem\_pointer & Указатель на объект семафора &  \\ \hline
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & boolean & ret & \parbox{73mm}{\vspace{1mm} 
                                    \texttt{false} - в случае ошибки;\\
                                    \texttt{true} - в случае выставления семафора.
                                   } & \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local proc_pattern = [[
local semaphore_in = <semaphore_in>
local ret

-- Библиотека 'lproc_queue' автоматически подключается к созданному процессу
lproc_queue.delay_ms(500)

while true do
  print('from proc')
  ret = lproc_queue.sem_timedwait_ms(semaphore_in, 500)
end
]]

local semaphore__to_proc = lproc_queue.sem_create()
local proc = string.gsub(proc_pattern, '<semaphore_in>', string.format("0x%016X", semaphore__to_proc))

local ret = lproc_queue.proc_start(proc)

if (ret == false) then
  print('ERROR')
  os.exit()
end

while true do
  lproc_queue.delay_ms(321)
  ret = lproc_queue.sem_post(semaphore__to_proc)  --[[ <--- ]]
  if (ret == false) then
    print('ERROR')
  end
end

\end{Lua}




\newpage
\subsubsection{\texttt{sem\_timedwait\_ms()} - блокирующее ожидание семафора или истечения таймаута}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{26mm}|L{73mm}|C{21mm}|}
  \caption{Функция \texttt{ sem\_timedwait\_ms() }} \label{t:sem_timedwait_ms} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering (boolean ret), (string status) = sem\_timedwait\_ms(integer sem\_pointer, integer timeout\_ms) } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:sem_timedwait_ms}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{26mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{21mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorArgs}
  \multicolumn{5}{|c|}{\centering Аргументы } \\\hline
  1 & integer & sem\_pointer & Указатель на объект семафора &  \\ \hline
  2 & integer & timeout\_ms  & Таймаут ожидания, мС &  \\ \hline
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & boolean & ret & \parbox{73mm}{\vspace{1mm} 
                                    \texttt{false} - в случае ошибки или таймаута;\\
                                    \texttt{true} - в случае получения семафора.
                                   } & \\ \hline
  2 & string & status & \parbox{73mm}{\vspace{1mm} 
                                    Если первый возвращаемый аргумент \texttt{false}, то: \\
                                    \texttt{timeout} - в случае таймаута;\\
                                    \texttt{error} - в случае ошибки.
                                   } &  \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local proc_pattern = [[
local semaphore_in = <semaphore_in>
local ret

-- Библиотека 'lproc_queue' автоматически подключается к созданному процессу
lproc_queue.delay_ms(500)

while true do
  print('from proc')
  ret = lproc_queue.sem_timedwait_ms(semaphore_in, 500)
end
]]

local semaphore__to_proc = lproc_queue.sem_create()
local proc = string.gsub(proc_pattern, '<semaphore_in>', string.format("0x%016X", semaphore__to_proc))

local ret = lproc_queue.proc_start(proc)

if (ret == false) then
  print('ERROR')
  os.exit()
end

while true do
  lproc_queue.delay_ms(321)
  ret = lproc_queue.sem_post(semaphore__to_proc)  --[[ <--- ]]
  if (ret == false) then
    print('ERROR')
  end
end
\end{Lua}






\subsection{\texttt{debug\_mode()} - включение режима выдачи отладочных сообщений}

\small
\begin{longtable}{|C{7mm}|C{15mm}|C{30mm}|L{73mm}|C{17mm}|}
  \caption{Функция \texttt{ debug\_mode() }} \label{t:debug_mode} \\
  \hline
  \rowcolor{ColorFunction}
  \multicolumn{5}{|c|}{\centering  (string debug\_info) = debug\_mode(string debug\_enable\_flags) } \\\hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{30mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{17mm}|}{\centering По умолчанию} \\\hline
  \endfirsthead
  \caption*{Продолжение таблицы \ref{t:debug_mode}} \\
  \hline
  \rowcolor{Gray}
  \multicolumn{1}{|C{7mm}}{№} &
  \multicolumn{1}{|C{15mm}}{\centering Тип} &
  \multicolumn{1}{|C{30mm}}{\centering Имя} &
  \multicolumn{1}{|L{73mm}}{\centering Описание} &
  \multicolumn{1}{|C{17mm}|}{\centering По умолчанию} \\\hline
  \endhead
  \rowcolor{ColorArgs}
  \multicolumn{5}{|c|}{\centering Аргументы } \\\hline
  1 & string & debug\_enable\_flags & \parbox{73mm}{\vspace{1mm} 
                                         Флаги кастомизации отладки. Запись типа \\ \scriptsize\texttt{0b1000\_0000\_0000\_0000\_0000\_0000\_0000\_1111}\small (32-битное число, представленное в битовом формате. Старший бит слева).\\
                                         \\
                                         Младшие биты 3, 2, 1, 0 отвечают за тип отладочных сообщений (записи в коде \texttt{info\_3("--//--");}, \texttt{info\_2("--//--");}, \texttt{info\_1("--//--");}, \texttt{info\_0("--//--");} соответственно).\\
                                         \\
                                         Все остальные старшие биты отвечают за файлы из которых выводятся отладочные сообщения.
                                      \vspace{1mm} } &  \\ \hline
  \rowcolor{ColorRet}
  \multicolumn{5}{|c|}{\centering Возвращаемые значения } \\\hline
  1 & string & debug\_info & Отчет о кастомизации отладки &  \\ \hline
\end{longtable} \normalsize


\begin{Lua}
local lproc_queue = require('lproc_queue')

local debug_info = lproc_queue.debug_mode('0b1000_0000_0000_0000_0000_0000_0000_1111') --[[ <--- ]]
print(debug_info)
\end{Lua}





\end{document}
